# Архитектура проекта

Проект построен полностью на основе методологии Feature-Sliced Design (FSD), что обеспечивает четкое разделение ответственности и улучшает масштабируемость.

## Стандартизация архитектурного подхода

> **ВАЖНО**: Проект должен следовать единой архитектуре Feature-Sliced Design (FSD) без элементов других архитектурных подходов.

> **РЕШЕНИЕ**: Проект использует исключительно **App Router** от Next.js, директория `pages` объявлена устаревшей и будет удалена. Весь новый код должен размещаться в соответствующих директориях согласно FSD с точкой входа через `app`.

## Основные слои

### domain/

Содержит бизнес-модели и логику, независимую от фреймворков и внешних зависимостей.

- `anonymize/` - модель для анонимизации текста
- `text/` - модель для работы с текстом

### entities/

Бизнес-сущности с минимальной логикой, используемые в разных фичах.

### features/

Функциональные модули, реализующие конкретные пользовательские сценарии.

- `anonymize/` - функциональность анонимизации текста
  - `api/` - API-клиенты и адаптеры
  - `ui/` - компоненты пользовательского интерфейса фичи
    - `client/` - клиентские компоненты (с директивой 'use client')
    - `server/` - серверные компоненты (без директивы)
  - `lib/` - вспомогательные утилиты и хелперы
  - `model/` - модели состояний и бизнес-логика
  - `actions/` - серверные действия (Server Actions)
- `theme/` - функциональность темы
  - `ui/` - компоненты управления темой
    - `client/` - клиентские компоненты для управления темой
  - `model/` - модель и константы темы

### widgets/

Композиционный слой, объединяющий фичи в более крупные блоки интерфейса.

- `anonymize/` - виджет анонимизации для главной страницы
  - `ui/` - компоненты пользовательского интерфейса
    - `client/` - клиентские компоненты
    - `server/` - серверные компоненты

### app/

Слой приложения, определяющий инициализацию приложения и маршрутизацию через App Router.

### shared/

Переиспользуемые модули, не зависящие от бизнес-логики проекта.

- `ui/` - базовые UI-компоненты
  - `client/` - клиентские UI-компоненты (с директивой 'use client')
  - `server/` - серверные UI-компоненты
  - **Организация UI-компонентов по функциональности:**
  - `button/` - кнопки и элементы управления
  - `card/` - карточки и контейнеры
  - `inputs/` - поля ввода и формы
  - `navigation/` - компоненты навигации и меню
  - `media/` - изображения и иконки
  - `layout/` - компоненты разметки
  - `feedback/` - компоненты обратной связи
  - `providers/` - провайдеры контекста
  - `accessibility/` - компоненты доступности
- `lib/` - утилиты и вспомогательные функции
  - `client/` - клиентские утилиты
  - `server/` - серверные утилиты
  - `utils.ts` - общие утилиты, включая cn для комбинирования стилей
  - `useAnonymize.ts` - хуки для анонимизации
  - `sanitize.ts` - утилиты для санитизации данных
- `hooks/` - общие хуки для переиспользования в разных частях приложения
- `api/` - абстракции для работы с API

## Стили и композиция

Для стилизации используется сочетание Tailwind CSS и композиционного подхода. Общие стили собраны в `src/styles/compositions.ts`:

```tsx
import { typography, layout, spacing, cards, animations, transitions } from '@/styles/compositions';

// Пример использования
<div className={layout.flexColumn}>
  <h2 className={typography.h2}>Заголовок</h2>
  <div className={layout.flexBetween}>
    <button className={buttonsVariants({ variant: 'primary' })}>Кнопка</button>
    <div className={cards.base}>Карточка</div>
  </div>
</div>;
```

Для объединения классов используется утилита `cn` из `@/shared/lib/utils`.

```tsx
// НЕ ИСПОЛЬЗУЙТЕ конкатенацию строк
// ❌ Неправильно
className={flexStyles.row + ' ' + flexStyles.center}

// ✅ Правильно
className={cn(flexStyles.row, flexStyles.center)}
```

## Клиент-серверное разделение

В проекте используется React Server Components в соответствии с Next.js App Router:

1. **Серверные компоненты** (по умолчанию):

   - Загружают данные с сервера
   - Взаимодействуют с базой данных
   - Доступ к серверным ресурсам
   - Не имеют директивы 'use client'

2. **Клиентские компоненты** (нуждаются в явном объявлении):
   - Используют хуки React (useState, useEffect)
   - Обрабатывают события пользователя
   - Имеют директиву 'use client' в начале файла

Разделение клиент-сервер происходит на уровне UI:

```
shared/ui/
├── server/  # Серверные компоненты
└── client/  # Клиентские компоненты ('use client')
```

## Преимущества архитектуры

1. **Четкое разделение бизнес-логики и представления**

   - Бизнес-логика вынесена в слой `domain`
   - UI-компоненты не содержат бизнес-логики

2. **Улучшенная переиспользуемость**

   - Структурированные базовые компоненты в `shared/ui`
   - Общие утилиты в `shared/lib`
   - Унифицированные стили в `styles/compositions.ts`

3. **Улучшенная тестируемость**

   - Ясное разделение уровней абстракции
   - Модели можно тестировать независимо от UI

4. **Поддержка параллельной разработки**
   - Разные команды могут работать над разными фичами
   - Меньше конфликтов при слиянии

## Примеры использования

### Импорт компонентов

```tsx
// Импорт клиентских UI компонентов
import { Button, Card } from '@/shared/ui';

// Импорт серверных UI компонентов
import { DataTable } from '@/shared/ui/utils/server-component';

// Импорт бизнес-логики
import { anonymizeText } from '@/domain/anonymize';

// Импорт готовых фич
import { AnonymizeForm } from '@/features/anonymize/ui/client';

// Импорт серверных действий
import { processData } from '@/features/anonymize/actions';

// Импорт виджетов
import { AnonymizeWidget } from '@/widgets/anonymize/ui/server';
```

### Архитектурные принципы

1. **Слои могут зависеть только от нижележащих слоев**:

   - `app` → `widgets` → `features` → `entities` → `domain` → базовые типы
   - `shared` доступен для всех слоев

2. **Отделение бизнес-логики**:

   - Бизнес-логика должна находиться в `domain` или `entities`
   - UI-компоненты не должны содержать бизнес-логику

3. **Инкапсуляция**:

   - Каждый модуль предоставляет публичный API через `index.ts`
   - Внутренняя реализация скрыта от других модулей

4. **Поддержка доступности**:

   - Все компоненты должны соответствовать WCAG 2.1 AA
   - Тесты доступности в `e2e/a11y.spec.ts`
   - Все интерактивные элементы должны иметь проверенные фокусные состояния и стили `focus-visible`

5. **Производительность**:
   - Использование `withMemo` для мемоизации компонентов
   - Оптимизация ререндеров
   - Использование Next.js Image для оптимизации изображений
   - Использование серверных компонентов для уменьшения JS-бандла
